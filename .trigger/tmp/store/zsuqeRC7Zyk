{
  "version": 3,
  "sources": ["../../../src/trigger/workflow.ts", "../../../src/lib/execution/engine.ts", "../../../src/lib/execution/ExecutorRegistry.ts", "../../../src/lib/execution/nodes/TextNodeExecutor.ts", "../../../src/lib/execution/nodes/DebugNodeExecutor.ts", "../../../src/lib/execution/nodes/LLMNodeExecutor.ts", "../../../src/lib/execution/nodes/VisionNodeExecutor.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\r\nimport { runWorkflow } from \"@/lib/execution/engine\";\r\nimport { Node, Edge } from \"@xyflow/react\";\r\n\r\nexport const workflowTask = task({\r\n    id: \"workflow-task\",\r\n    maxDuration: 600, // 10 minutes\r\n    run: async (payload: { nodes: Node[]; edges: Edge[] }) => {\r\n        console.log(\"ðŸš€ Starting workflow execution...\");\r\n        console.log(`ðŸ“Š Received ${payload.nodes.length} nodes and ${payload.edges.length} edges.`);\r\n\r\n        // Track node status\r\n        const nodeStatus: Record<string, 'idle' | 'running' | 'completed' | 'error'> = {};\r\n        payload.nodes.forEach(node => {\r\n            nodeStatus[node.id] = 'idle';\r\n        });\r\n\r\n        try {\r\n            // Run the deterministic engine\r\n            const context = await runWorkflow(payload.nodes, payload.edges, (nodeId, status) => {\r\n                console.log(`[${nodeId}] âž¡ï¸ ${status}`);\r\n                nodeStatus[nodeId] = status;\r\n            });\r\n\r\n            // Extract LLM response for top-level visibility (User Requirement)\r\n            const llmResult = Array.from(context.nodeResults.values()).find((r: any) => r.llmResponse);\r\n\r\n            console.log(\"âœ… Workflow execution complete.\");\r\n\r\n            // Return the serializable parts of the context\r\n            return {\r\n                success: true,\r\n                executionId: context.executionId,\r\n                results: Object.fromEntries(context.nodeResults),\r\n                llmResponse: llmResult ? (llmResult as any).llmResponse : undefined, // Bubble up for debug/UI checks\r\n                logs: context.logs,\r\n                nodeStatus, // Per-node status for UI\r\n                nodesExecuted: context.logs.filter(l => l.message.includes('Executing')).length\r\n            };\r\n\r\n        } catch (error: any) {\r\n            console.error(\"âŒ Workflow failed:\", error);\r\n\r\n            // Return structured error response\r\n            return {\r\n                success: false,\r\n                error: error.message || \"Unknown error occurred\",\r\n                stack: error.stack,\r\n                failedAt: new Date().toISOString(),\r\n                nodeStatus // Include partial status even on failure\r\n            };\r\n        }\r\n    },\r\n});\r\n", "import { Edge, Node } from \"@xyflow/react\";\r\nimport { ExecutableNode, ExecutionContext, ExecutionLog } from \"./types\";\r\nimport { executorRegistry } from \"./ExecutorRegistry\";\r\n\r\n/**\r\n * Determines the execution execution order of nodes based on the graph topology.\r\n * Uses Kahn's algorithm for Topological Sort.\r\n * \r\n * @param nodes - All nodes in the flow\r\n * @param edges - All edges in the flow\r\n * @returns Array of Node IDs in execution order\r\n * @throws Error if a cycle is detected\r\n */\r\nexport const getExecutionOrder = (nodes: Node[], edges: Edge[]): string[] => {\r\n    // 1. Initialize data structures\r\n    const inDegree = new Map<string, number>();\r\n    const adjList = new Map<string, string[]>();\r\n\r\n    // Initialize in-degrees to 0 for all nodes\r\n    nodes.forEach(node => {\r\n        inDegree.set(node.id, 0);\r\n        adjList.set(node.id, []);\r\n    });\r\n\r\n    // 2. Build Adjacency List and In-Degree Map\r\n    edges.forEach(edge => {\r\n        const source = edge.source;\r\n        const target = edge.target;\r\n\r\n        // If edge connects to nodes not in our list (e.g. deleted), skip\r\n        if (!inDegree.has(source) || !inDegree.has(target)) return;\r\n\r\n        // Add to adjacency list (Source -> [Targets])\r\n        adjList.get(source)?.push(target);\r\n\r\n        // Increment in-degree of target\r\n        inDegree.set(target, (inDegree.get(target) || 0) + 1);\r\n    });\r\n\r\n    // 3. Queue nodes with in-degree 0 (no dependencies)\r\n    const queue: string[] = [];\r\n    inDegree.forEach((degree, id) => {\r\n        if (degree === 0) {\r\n            queue.push(id);\r\n        }\r\n    });\r\n\r\n    const executionOrder: string[] = [];\r\n\r\n    // 4. Process Queue\r\n    while (queue.length > 0) {\r\n        const currentId = queue.shift()!;\r\n        executionOrder.push(currentId);\r\n\r\n        const neighbors = adjList.get(currentId) || [];\r\n        for (const neighbor of neighbors) {\r\n            inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);\r\n\r\n            if (inDegree.get(neighbor) === 0) {\r\n                queue.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 5. Check for Cycles\r\n    if (executionOrder.length !== nodes.length) {\r\n        throw new Error(\"Cycle detected in workflow: Execution flow contains circular dependencies.\");\r\n    }\r\n\r\n    return executionOrder;\r\n};\r\n\r\n/**\r\n * Standalone executor for LLM nodes to guarantee output format.\r\n * Uses native fetch for Groq (Llama 3) to strictly avoid dependency issues.\r\n */\r\nexport async function executeLLMNode({ prompt }: { prompt: string }) {\r\n    if (!process.env.GROQ_API_KEY) {\r\n        console.warn(\"âš ï¸ No GROQ_API_KEY found, using mock response\");\r\n        return \"This is a mock AI response for demonstration purposes.\";\r\n    }\r\n\r\n    console.log(`ðŸš€ Sending prompt to Groq (Llama 3) via fetch: \"${prompt.substring(0, 50)}...\"`);\r\n\r\n    try {\r\n        const response = await fetch(\"https://api.groq.com/openai/v1/chat/completions\", {\r\n            method: \"POST\",\r\n            headers: {\r\n                \"Authorization\": `Bearer ${process.env.GROQ_API_KEY}`,\r\n                \"Content-Type\": \"application/json\"\r\n            },\r\n            body: JSON.stringify({\r\n                model: \"llama3-8b-8192\",\r\n                messages: [{ role: \"user\", content: prompt }]\r\n            })\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const errorBody = await response.text();\r\n            throw new Error(`Groq API Error: ${response.status} - ${errorBody}`);\r\n        }\r\n\r\n        const data = await response.json();\r\n        const text = data.choices?.[0]?.message?.content || \"No response\";\r\n\r\n        console.log(\"âœ… Groq response received length:\", text.length);\r\n        return text;\r\n\r\n    } catch (error: any) {\r\n        console.error(\"âŒ Groq API execution error:\", error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Orchestrates the execution of the workflow.\r\n */\r\nexport const runWorkflow = async (\r\n    nodes: Node[],\r\n    edges: Edge[],\r\n    onStatusChange?: (nodeId: string, status: 'running' | 'completed' | 'error') => void\r\n): Promise<ExecutionContext> => {\r\n\r\n    // 1. Get execution order\r\n    const executionOrder = getExecutionOrder(nodes, edges);\r\n\r\n    // 2. Initialize Context\r\n    const context: ExecutionContext = {\r\n        executionId: crypto.randomUUID(),\r\n        nodeResults: new Map(),\r\n        logs: [],\r\n        log: (nodeId: string, message: string) => {\r\n            console.log(`[${nodeId}] ${message}`);\r\n            context.logs.push({\r\n                nodeId,\r\n                message,\r\n                timestamp: Date.now()\r\n            });\r\n        }\r\n    };\r\n\r\n    // 3. Execute Nodes in Order\r\n    for (const nodeId of executionOrder) {\r\n        const node = nodes.find(n => n.id === nodeId);\r\n        if (!node) continue;\r\n\r\n        console.log(\"ðŸ”¥ EXECUTING NODE\", node.id, node.type);\r\n\r\n        const nodeType = node.type || \"unknown\";\r\n\r\n        // Guaranteed LLM Execution Path (Robust Fuzzy Match)\r\n        if (nodeType.toLowerCase().includes(\"llm\") || nodeType.toLowerCase().includes(\"ai\")) {\r\n            try {\r\n                if (onStatusChange) onStatusChange(nodeId, 'running');\r\n\r\n                // Collect inputs from upstream nodes\r\n                const inputEdges = edges.filter(e => e.target === nodeId);\r\n                const inputs: Record<string, unknown> = { ...node.data };\r\n\r\n                for (const edge of inputEdges) {\r\n                    const sourceResult = context.nodeResults.get(edge.source);\r\n                    if (sourceResult) {\r\n                        Object.assign(inputs, sourceResult);\r\n                    }\r\n                }\r\n\r\n                const prompt = (inputs.text as string) || (inputs.prompt as string) || (inputs.value as string) || \"\";\r\n\r\n                if (!prompt) {\r\n                    throw new Error(\"LLM node received empty prompt\");\r\n                }\r\n\r\n                context.log(nodeId, `Executing LLM Node with prompt: \"${prompt.substring(0, 50)}...\"`);\r\n\r\n                const geminiText = await executeLLMNode({\r\n                    prompt: prompt,\r\n                });\r\n\r\n                context.log(nodeId, `Generated ${geminiText.length} characters`);\r\n\r\n                context.nodeResults.set(nodeId, {\r\n                    llmResponse: {\r\n                        text: geminiText,\r\n                    },\r\n                });\r\n\r\n                if (onStatusChange) onStatusChange(nodeId, 'completed');\r\n                continue; // Skip generic executor\r\n\r\n            } catch (error: any) {\r\n                context.log(nodeId, `Error in LLM execution: ${error.message}`);\r\n                console.error(`[${nodeId}] Full Error Stack:`, error);\r\n                if (onStatusChange) onStatusChange(nodeId, 'error');\r\n                // We rethrow so the workflow engine knows it failed\r\n                throw error;\r\n            }\r\n        }\r\n\r\n        const ExecutorClass = executorRegistry[nodeType];\r\n\r\n        if (!ExecutorClass) {\r\n            context.log(nodeId, `No executor found for type: ${nodeType}`);\r\n            continue;\r\n        }\r\n\r\n        try {\r\n            if (onStatusChange) onStatusChange(nodeId, 'running');\r\n\r\n            const executor = new ExecutorClass();\r\n\r\n            // Collect inputs from upstream nodes\r\n            // Find edges where target is this node\r\n            const inputEdges = edges.filter(e => e.target === nodeId);\r\n            const inputs: Record<string, unknown> = { ...node.data };\r\n\r\n            for (const edge of inputEdges) {\r\n                const sourceResult = context.nodeResults.get(edge.source);\r\n                if (sourceResult) {\r\n                    // Start simple: merge all upstream results\r\n                    // In real engine, we'd map handles\r\n                    Object.assign(inputs, sourceResult);\r\n                }\r\n            }\r\n\r\n            const output = await executor.execute(inputs, context);\r\n            context.nodeResults.set(nodeId, output);\r\n\r\n            if (onStatusChange) onStatusChange(nodeId, 'completed');\r\n\r\n        } catch (error: any) {\r\n            context.log(nodeId, `Error executing node: ${error.message}`);\r\n            if (onStatusChange) onStatusChange(nodeId, 'error');\r\n            throw error; // Stop execution on error for now\r\n        }\r\n    }\r\n\r\n    return context;\r\n};\r\n", "import { ExecutableNode } from \"./types\";\r\nimport { TextNodeExecutor } from \"./nodes/TextNodeExecutor\";\r\nimport { DebugNodeExecutor } from \"./nodes/DebugNodeExecutor\";\r\nimport { LLMNodeExecutor } from \"./nodes/LLMNodeExecutor\";\r\nimport { VisionNodeExecutor } from \"./nodes/VisionNodeExecutor\";\r\n\r\nexport const executorRegistry: Record<string, new () => ExecutableNode> = {\r\n    text: TextNodeExecutor,\r\n    debug: DebugNodeExecutor,\r\n    llm: LLMNodeExecutor,\r\n    vision: VisionNodeExecutor,\r\n};\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class TextNodeExecutor implements ExecutableNode {\r\n    async execute(input: Record<string, unknown>, context: ExecutionContext): Promise<Record<string, unknown>> {\r\n        context.log(\"text\", \"Executing Text Node...\");\r\n\r\n        // In a real scenario, input might come from the node data itself if passed in input\r\n        // But for a source node, we usually rely on the node's configuration data \r\n        // which should be passed via the input or a separate config.\r\n        // For now, let's assume the text value is passed in the input 'data' field \r\n        // or we simulate looking it up if we had access to the node config directly.\r\n\r\n        // However, the cleanest way in this architecture is that the 'input' arg \r\n        // contains the node's own data as well (or we fetch it).\r\n        // Let's assume input contains { value: \"some text\" } for this mock.\r\n\r\n        const textValue = input.value as string || \"Default Text\";\r\n\r\n        context.log(\"text\", `Generated text: \"${textValue}\"`);\r\n\r\n        return {\r\n            text: textValue\r\n        };\r\n    }\r\n}\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class DebugNodeExecutor implements ExecutableNode {\r\n    async execute(input: Record<string, unknown>, context: ExecutionContext): Promise<Record<string, unknown>> {\r\n        context.log(\"debug\", \"Executing Debug Node...\");\r\n\r\n        // Log all inputs to the console/context\r\n        const inputs = Object.entries(input).map(([key, val]) => `${key}: ${val}`).join(\", \");\r\n        context.log(\"debug\", `Received inputs: { ${inputs} }`);\r\n\r\n        // Pass input through as output (identity)\r\n        return input;\r\n    }\r\n}\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class LLMNodeExecutor implements ExecutableNode {\r\n    async execute(input: any, context: ExecutionContext): Promise<any> {\r\n        context.log(this.constructor.name, \"LLMNodeExecutor is deprecated. engine.ts now handles LLM nodes directly.\");\r\n\r\n        throw new Error(\r\n            \"LLMNodeExecutor should not be called directly. execution/engine.ts should intercept 'llm' nodes.\"\r\n        );\r\n    }\r\n}\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class VisionNodeExecutor implements ExecutableNode {\r\n    async execute(input: any, context: ExecutionContext): Promise<any> {\r\n        context.log(this.constructor.name, \"VisionNodeExecutor is currently disabled due to Groq migration.\");\r\n\r\n        throw new Error(\r\n            \"Vision Node is not yet supported in the Groq migration. Please check back later.\"\r\n        );\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
