{
  "version": 3,
  "sources": ["../../../src/trigger/workflow.ts", "../../../src/lib/execution/engine.ts", "../../../src/lib/execution/ExecutorRegistry.ts", "../../../src/lib/execution/nodes/DebugNodeExecutor.ts", "../../../src/lib/execution/nodes/TextNodeExecutor.ts"],
  "sourcesContent": ["import { task } from \"@trigger.dev/sdk/v3\";\r\nimport { runWorkflow } from \"@/lib/execution/engine\";\r\nimport { Node, Edge } from \"@xyflow/react\";\r\n\r\nexport const workflowTask = task({\r\n    id: \"workflow-task\",\r\n    maxDuration: 600, // 10 minutes\r\n    run: async (payload: { nodes: Node[]; edges: Edge[] }) => {\r\n        console.log(\"ðŸš€ Starting workflow execution...\");\r\n        console.log(`ðŸ“Š Received ${payload.nodes.length} nodes and ${payload.edges.length} edges.`);\r\n\r\n        // Track node status\r\n        const nodeStatus: Record<string, 'idle' | 'running' | 'completed' | 'error'> = {};\r\n        payload.nodes.forEach(node => {\r\n            nodeStatus[node.id] = 'idle';\r\n        });\r\n\r\n        try {\r\n            // Run the deterministic engine\r\n            const context = await runWorkflow(payload.nodes, payload.edges, (nodeId, status) => {\r\n                console.log(`[${nodeId}] âž¡ï¸ ${status}`);\r\n                nodeStatus[nodeId] = status;\r\n            });\r\n\r\n            console.log(\"âœ… Workflow execution complete.\");\r\n\r\n            // Return the serializable parts of the context\r\n            return {\r\n                success: true,\r\n                executionId: context.executionId,\r\n                results: Object.fromEntries(context.nodeResults),\r\n                logs: context.logs,\r\n                nodeStatus, // Per-node status for UI\r\n                nodesExecuted: context.logs.filter(l => l.message.includes('Executing')).length\r\n            };\r\n\r\n        } catch (error: any) {\r\n            console.error(\"âŒ Workflow failed:\", error);\r\n\r\n            // Return structured error response\r\n            return {\r\n                success: false,\r\n                error: error.message || \"Unknown error occurred\",\r\n                stack: error.stack,\r\n                failedAt: new Date().toISOString(),\r\n                nodeStatus // Include partial status even on failure\r\n            };\r\n        }\r\n    },\r\n});\r\n", "import { Edge, Node } from \"@xyflow/react\";\r\nimport { ExecutableNode, ExecutionContext, ExecutionLog } from \"./types\";\r\nimport { executorRegistry } from \"./ExecutorRegistry\";\r\n\r\n/**\r\n * Determines the execution execution order of nodes based on the graph topology.\r\n * Uses Kahn's algorithm for Topological Sort.\r\n * \r\n * @param nodes - All nodes in the flow\r\n * @param edges - All edges in the flow\r\n * @returns Array of Node IDs in execution order\r\n * @throws Error if a cycle is detected\r\n */\r\nexport const getExecutionOrder = (nodes: Node[], edges: Edge[]): string[] => {\r\n    // 1. Initialize data structures\r\n    const inDegree = new Map<string, number>();\r\n    const adjList = new Map<string, string[]>();\r\n\r\n    // Initialize in-degrees to 0 for all nodes\r\n    nodes.forEach(node => {\r\n        inDegree.set(node.id, 0);\r\n        adjList.set(node.id, []);\r\n    });\r\n\r\n    // 2. Build Adjacency List and In-Degree Map\r\n    edges.forEach(edge => {\r\n        const source = edge.source;\r\n        const target = edge.target;\r\n\r\n        // If edge connects to nodes not in our list (e.g. deleted), skip\r\n        if (!inDegree.has(source) || !inDegree.has(target)) return;\r\n\r\n        // Add to adjacency list (Source -> [Targets])\r\n        adjList.get(source)?.push(target);\r\n\r\n        // Increment in-degree of target\r\n        inDegree.set(target, (inDegree.get(target) || 0) + 1);\r\n    });\r\n\r\n    // 3. Queue nodes with in-degree 0 (no dependencies)\r\n    const queue: string[] = [];\r\n    inDegree.forEach((degree, id) => {\r\n        if (degree === 0) {\r\n            queue.push(id);\r\n        }\r\n    });\r\n\r\n    const executionOrder: string[] = [];\r\n\r\n    // 4. Process Queue\r\n    while (queue.length > 0) {\r\n        const currentId = queue.shift()!;\r\n        executionOrder.push(currentId);\r\n\r\n        const neighbors = adjList.get(currentId) || [];\r\n        for (const neighbor of neighbors) {\r\n            inDegree.set(neighbor, (inDegree.get(neighbor) || 0) - 1);\r\n\r\n            if (inDegree.get(neighbor) === 0) {\r\n                queue.push(neighbor);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 5. Check for Cycles\r\n    if (executionOrder.length !== nodes.length) {\r\n        throw new Error(\"Cycle detected in workflow: Execution flow contains circular dependencies.\");\r\n    }\r\n\r\n    return executionOrder;\r\n};\r\n\r\n/**\r\n * Orchestrates the execution of the workflow.\r\n */\r\nexport const runWorkflow = async (\r\n    nodes: Node[],\r\n    edges: Edge[],\r\n    onStatusChange?: (nodeId: string, status: 'running' | 'completed' | 'error') => void\r\n): Promise<ExecutionContext> => {\r\n\r\n    // 1. Get execution order\r\n    const executionOrder = getExecutionOrder(nodes, edges);\r\n\r\n    // 2. Initialize Context\r\n    const context: ExecutionContext = {\r\n        executionId: crypto.randomUUID(),\r\n        nodeResults: new Map(),\r\n        logs: [],\r\n        log: (nodeId: string, message: string) => {\r\n            console.log(`[${nodeId}] ${message}`);\r\n            context.logs.push({\r\n                nodeId,\r\n                message,\r\n                timestamp: Date.now()\r\n            });\r\n        }\r\n    };\r\n\r\n    // 3. Execute Nodes in Order\r\n    for (const nodeId of executionOrder) {\r\n        const node = nodes.find(n => n.id === nodeId);\r\n        if (!node) continue;\r\n\r\n        const nodeType = node.type || \"unknown\";\r\n        const ExecutorClass = executorRegistry[nodeType];\r\n\r\n        if (!ExecutorClass) {\r\n            context.log(nodeId, `No executor found for type: ${nodeType}`);\r\n            continue;\r\n        }\r\n\r\n        try {\r\n            if (onStatusChange) onStatusChange(nodeId, 'running');\r\n\r\n            const executor = new ExecutorClass();\r\n\r\n            // Collect inputs from upstream nodes\r\n            // Find edges where target is this node\r\n            const inputEdges = edges.filter(e => e.target === nodeId);\r\n            const inputs: Record<string, unknown> = { ...node.data };\r\n\r\n            for (const edge of inputEdges) {\r\n                const sourceResult = context.nodeResults.get(edge.source);\r\n                if (sourceResult) {\r\n                    // Start simple: merge all upstream results\r\n                    // In real engine, we'd map handles\r\n                    Object.assign(inputs, sourceResult);\r\n                }\r\n            }\r\n\r\n            const output = await executor.execute(inputs, context);\r\n            context.nodeResults.set(nodeId, output);\r\n\r\n            if (onStatusChange) onStatusChange(nodeId, 'completed');\r\n\r\n        } catch (error: any) {\r\n            context.log(nodeId, `Error executing node: ${error.message}`);\r\n            if (onStatusChange) onStatusChange(nodeId, 'error');\r\n            throw error; // Stop execution on error for now\r\n        }\r\n    }\r\n\r\n    return context;\r\n};\r\n", "import { ExecutableNode } from \"./types\";\r\nimport { DebugNodeExecutor } from \"./nodes/DebugNodeExecutor\";\r\nimport { TextNodeExecutor } from \"./nodes/TextNodeExecutor\";\r\n\r\nexport const executorRegistry: Record<string, new () => ExecutableNode> = {\r\n    \"debug\": DebugNodeExecutor,\r\n    \"text\": TextNodeExecutor,\r\n};\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class DebugNodeExecutor implements ExecutableNode {\r\n    async execute(input: Record<string, unknown>, context: ExecutionContext): Promise<Record<string, unknown>> {\r\n        context.log(\"debug\", \"Executing Debug Node...\");\r\n\r\n        // Log all inputs to the console/context\r\n        const inputs = Object.entries(input).map(([key, val]) => `${key}: ${val}`).join(\", \");\r\n        context.log(\"debug\", `Received inputs: { ${inputs} }`);\r\n\r\n        // Pass input through as output (identity)\r\n        return input;\r\n    }\r\n}\r\n", "import { ExecutableNode, ExecutionContext } from \"../types\";\r\n\r\nexport class TextNodeExecutor implements ExecutableNode {\r\n    async execute(input: Record<string, unknown>, context: ExecutionContext): Promise<Record<string, unknown>> {\r\n        context.log(\"text\", \"Executing Text Node...\");\r\n\r\n        // In a real scenario, input might come from the node data itself if passed in input\r\n        // But for a source node, we usually rely on the node's configuration data \r\n        // which should be passed via the input or a separate config.\r\n        // For now, let's assume the text value is passed in the input 'data' field \r\n        // or we simulate looking it up if we had access to the node config directly.\r\n\r\n        // However, the cleanest way in this architecture is that the 'input' arg \r\n        // contains the node's own data as well (or we fetch it).\r\n        // Let's assume input contains { value: \"some text\" } for this mock.\r\n\r\n        const textValue = input.value as string || \"Default Text\";\r\n\r\n        context.log(\"text\", `Generated text: \"${textValue}\"`);\r\n\r\n        return {\r\n            text: textValue\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
